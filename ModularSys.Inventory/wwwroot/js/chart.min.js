// Simple Chart.js Implementation for ModularSys
window.renderChart = function(canvasId, type, data, options) {
    try {
        console.log('Simple renderChart called:', { canvasId, type, data });
        
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            console.error('Canvas not found:', canvasId);
            return;
        }
        
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        
        // Set canvas size
        canvas.width = rect.width;
        canvas.height = rect.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Colors
        const colors = ['#1976D2', '#388E3C', '#F57C00', '#9C27B0', '#F44336'];
        
        if (!data || !data.datasets || data.datasets.length === 0) {
            // Draw "No Data" message
            ctx.fillStyle = '#666';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('No Data Available', canvas.width / 2, canvas.height / 2);
            return;
        }
        
        const padding = 40;
        const chartWidth = canvas.width - 2 * padding;
        const chartHeight = canvas.height - 2 * padding;
        
        if (type === 'bar') {
            drawBarChart(ctx, data, padding, chartWidth, chartHeight, colors);
        } else if (type === 'line') {
            drawLineChart(ctx, data, padding, chartWidth, chartHeight, colors);
        } else if (type === 'pie') {
            drawPieChart(ctx, data, canvas.width, canvas.height, colors);
        } else if (type === 'doughnut') {
            drawDoughnutChart(ctx, data, canvas.width, canvas.height, colors);
        }
        
        console.log('Chart rendered successfully');
        
    } catch (error) {
        console.error('Error rendering chart:', error);
    }
};

function drawBarChart(ctx, data, padding, chartWidth, chartHeight, colors) {
    const dataset = data.datasets[0];
    const values = dataset.data;
    const labels = data.labels;
    
    if (!values || values.length === 0) return;
    
    const maxValue = Math.max(...values);
    const barWidth = chartWidth / values.length * 0.8;
    const barSpacing = chartWidth / values.length * 0.2;
    
    // Draw bars
    values.forEach((value, index) => {
        const barHeight = (value / maxValue) * chartHeight;
        const x = padding + index * (barWidth + barSpacing);
        const y = padding + chartHeight - barHeight;
        
        ctx.fillStyle = colors[index % colors.length];
        ctx.fillRect(x, y, barWidth, barHeight);
        
        // Draw value on top
        ctx.fillStyle = '#333';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(value.toString(), x + barWidth / 2, y - 5);
        
        // Draw label
        if (labels && labels[index]) {
            ctx.fillText(labels[index], x + barWidth / 2, padding + chartHeight + 20);
        }
    });
}

function drawLineChart(ctx, data, padding, chartWidth, chartHeight, colors) {
    const dataset = data.datasets[0];
    const values = dataset.data;
    const labels = data.labels;
    
    if (!values || values.length === 0) return;
    
    const maxValue = Math.max(...values);
    const minValue = Math.min(...values);
    const valueRange = maxValue - minValue || 1;
    
    // Draw line
    ctx.strokeStyle = colors[0];
    ctx.lineWidth = 3;
    ctx.beginPath();
    
    values.forEach((value, index) => {
        const x = padding + (index * chartWidth / (values.length - 1));
        const y = padding + chartHeight - ((value - minValue) / valueRange * chartHeight);
        
        if (index === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
        
        // Draw point
        ctx.fillStyle = colors[0];
        ctx.fillRect(x - 3, y - 3, 6, 6);
    });
    
    ctx.stroke();
    
    // Draw labels
    if (labels) {
        ctx.fillStyle = '#333';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        labels.forEach((label, index) => {
            const x = padding + (index * chartWidth / (labels.length - 1));
            ctx.fillText(label, x, padding + chartHeight + 20);
        });
    }
}

function drawPieChart(ctx, data, canvasWidth, canvasHeight, colors) {
    const dataset = data.datasets[0];
    const values = dataset.data;
    const labels = data.labels;
    
    if (!values || values.length === 0) return;
    
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    const radius = Math.min(centerX, centerY) - 50;
    
    const total = values.reduce((sum, value) => sum + value, 0);
    let currentAngle = -Math.PI / 2;
    
    values.forEach((value, index) => {
        const sliceAngle = (value / total) * 2 * Math.PI;
        
        ctx.fillStyle = colors[index % colors.length];
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
        ctx.lineTo(centerX, centerY);
        ctx.fill();
        
        // Draw label
        if (labels && labels[index]) {
            const labelAngle = currentAngle + sliceAngle / 2;
            const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
            const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
            
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(labels[index], labelX, labelY);
        }
        
        currentAngle += sliceAngle;
    });
}

function drawDoughnutChart(ctx, data, canvasWidth, canvasHeight, colors) {
    const dataset = data.datasets[0];
    const values = dataset.data;
    const labels = data.labels;
    
    if (!values || values.length === 0) return;
    
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    const outerRadius = Math.min(centerX, centerY) - 50;
    const innerRadius = outerRadius * 0.5;
    
    const total = values.reduce((sum, value) => sum + value, 0);
    let currentAngle = -Math.PI / 2;
    
    values.forEach((value, index) => {
        const sliceAngle = (value / total) * 2 * Math.PI;
        
        ctx.fillStyle = colors[index % colors.length];
        ctx.beginPath();
        ctx.arc(centerX, centerY, outerRadius, currentAngle, currentAngle + sliceAngle);
        ctx.arc(centerX, centerY, innerRadius, currentAngle + sliceAngle, currentAngle, true);
        ctx.fill();
        
        currentAngle += sliceAngle;
    });
    
    // Draw center text
    ctx.fillStyle = '#333';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Total', centerX, centerY - 5);
    ctx.font = '14px Arial';
    ctx.fillText(total.toString(), centerX, centerY + 15);
}
